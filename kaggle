import pandas as pd

class Arbeitszeiten_ETL_Handler:
    """
        Klasse zum Einlesen einer CSV-Datei mit Arbeitszeiten und Verarbeitung der Daten.
    :param _csv_path: Pfad zur CSV-Datei
    :param _df: DataFrame mit den Daten aus der CSV-Datei
    """

    def __init__(
            self,
            _csv_path: str
    ):
        """
            Initialisiert die Klasse mit dem Pfad zur CSV-Datei.

        :param _csv_path: Pfad zur CSV-Datei, welche die Arbeitszeiten enthält
        """
        self._csv_path = _csv_path  # Pfad direkt verwenden
        self.extract()

        # Bereinigung der Dezimalzahlen (Komma durch Punkt ersetzen)
        for column in self._df.columns[1:]:  # Spalte 0 ist der Name, daher beginnen wir mit der 1.
            self._df[column] = self._df[column].str.replace(',', '.').astype(float)

        self.transform()

    # extract ---------------------------------------------------------------------------------------------------------

    def extract(self) -> None:
        """
            Extrahiert die Daten aus der CSV-Datei und speichert sie in einem DataFrame.
        """
        self._df = pd.read_csv(
            self._csv_path,
            delimiter=';',  # Semikolon als Trennzeichen
        )

    # transform ---------------------------------------------------------------------------------------------------------

    def transform(self) -> None:
        """
            Transformiert die Arbeitszeitdaten und berechnet zusätzliche Werte.
        """
        # Umwandeln der Datumsformat-Spalten in Wochentage (nur ab der zweiten Spalte)
        self._df.columns = ['Name'] + [pd.to_datetime(col, format='%d.%m.%Y').strftime('%A') for col in self._df.columns[1:]]

        # Zähle die Vorkommen jedes Namens
        name_counts = self._df['Name'].value_counts()
        
        # Falls ein Name doppelt vorkommt, füge Nummern hinzu
        name_tracker = {}
        
        def modify_name(name):
            if name_counts[name] > 1:  # Nur für doppelte Namen Nummern hinzufügen
                if name in name_tracker:
                    name_tracker[name] += 1
                else:
                    name_tracker[name] = 1
                return f"{name}{name_tracker[name]}"
            return name  # Falls der Name einzigartig ist, bleibt er unverändert

        self._df['Name'] = self._df['Name'].astype(str).apply(modify_name)

        # Setzen des Index auf den angepassten Namen
        self._df = self._df.set_index('Name')

        # Umwandeln der Daten in ein langes Format (Melt)
        self._df_long = self._df.reset_index().melt(id_vars=['Name'], var_name='Wochentag', value_name='Arbeitszeit')

        # Berechnung der durchschnittlichen Arbeitszeit pro Wochentag
        self._df_avg = self._df_long.groupby(['Name', 'Wochentag'])['Arbeitszeit'].mean().unstack()

        # Umbenennen der Spalten in die gewünschten Wochentage
        self._df_avg.columns = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']

        # Hinzufügen der Spalte 'Week', die die Summe der anderen Spalten enthält
        self._df_avg['Week'] = self._df_avg.sum(axis=1)

        # Runden aller Zahlen auf zwei Nachkommastellen
        self._df_avg = self._df_avg.round(2)

    # get_data ---------------------------------------------------------------------------------------------------------

    def get_data(self) -> pd.DataFrame:
        """
            Gibt den transformierten DataFrame zurück.

        :return: DataFrame mit den transformierten Daten
        """
        return self._df_avg


# Main ---------------------------------------------------------------------------------------------------------

if __name__ == "__main__":
    # Pfad zur Arbeitszeiten CSV-Datei in Kaggle
    CSV_PATH = '/kaggle/input/arbeitszeiten/Arbeitszeiten.csv'  # Pfad in Kaggle

    # Initialisiere die Arbeitszeiten-Verarbeitungsklasse
    processor = Arbeitszeiten_ETL_Handler(CSV_PATH)

    # Hole die transformierten Daten
    df_avg = processor.get_data()

    # Setze die Option, um alle Zeilen anzuzeigen
    pd.set_option('display.max_rows', None)  # Zeigt alle Zeilen an

    # Zeige die transformierten Daten an
    print(df_avg)